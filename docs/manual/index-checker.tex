\htmlhr
% Reinstate when lists are supported:
% \chapterAndLabel{Index Checker for sequence bounds (arrays, strings, lists)}{index-checker}
\chapterAndLabel{Index Checker for sequence bounds (arrays and strings)}{index-checker}

The Index Checker warns about potentially out-of-bounds accesses to sequence
data structures, such as arrays
% , lists,
and strings.

The Index Checker prevents \<IndexOutOfBoundsException>s that result from
an index expression that might be negative or might be equal to or larger
than the sequence's length.
It also prevents \<NegativeArraySizeException>s that result from a negative
array dimension in an array creation expression.
(A caveat: the Index Checker does not check for arithmetic overflow. If
an expression overflows, the Index Checker might fail to warn about a
possible exception.  This is unlikely to be a problem in practice unless
you have an array whose length is \<Integer.MAX\_VALUE>.)

% Here's a pathological example of overflow leading to unsoundness:
%
% public class IndexOverflow {
%     public static void main(String[] args) {
%         @Positive int x = 1073741825; // 2 ^ 30 + 1
%         @Positive int x2 = x + x; // 2 ^ 31 + 2 == - 2 ^ 31 + 2
%         int[] a = new int[0];
%         if (x2 < a.length) {
%             a[x2] = 42;
%         }
%     }
% }

The programmer can write annotations that indicate which expressions are
indices for which sequences.  The Index Checker prohibits any operation that
may violate these properties, and the Index Checker takes advantage of
these properties when verifying indexing operations.
%
Typically, a programmer writes few annotations, because the Index Checker
infers properties of indexes from
the code around them. For example, it will infer that \<x> is positive
within the \<then> block of an \code{if (x > 0)} statement.
The programmer does need to write field types and method pre-conditions or post-conditions. For instance,
if a method's formal parameter is used as an index for
\<myArray>, the programmer might need to
write an \refqualclasswithparams{checker/index/qual}{IndexFor}{"myArray"}
annotation on the formal parameter's types.

The Index Checker checks fixed-size data structures, whose size is never
changed after creation.  A fixed-size data structure has no \<add> or
\<remove> operation.  Examples are strings and arrays, and you can add
support for other fixed-size data structures (see
Section~\ref{index-annotating-fixed-size}).

To run the Index Checker, run either of these commands:

\begin{alltt}
  javac -processor index \emph{MyJavaFile}.java
  javac -processor org.checkerframework.checker.index.IndexChecker \emph{MyJavaFile}.java
\end{alltt}

Recall that in Java, type annotations are written before the type;
in particular,
array annotations appear immediately before ``\<[]>''.
Here is how to declare a length-9 array of positive integers:

\begin{Verbatim}
  @Positive int @ArrayLen(9) []
\end{Verbatim}

Multi-dimensional arrays are similar.
Here is how to declare a length-2 array of length-4 arrays:

\begin{Verbatim}
  String @ArrayLen(2) [] @ArrayLen(4) []
\end{Verbatim}

The paper ``Lightweight Verification of Array Indexing'' (ISSTA 2018,
\myurl{https://homes.cs.washington.edu/~mernst/pubs/array-indexing-issta2018-abstract.html})
gives more details about the Index Checker.
``Enforcing correct array indexes with a type system''~\cite{Santino2016} (FSE 2016) describes
an earlier version.


\sectionAndLabel{Index Checker structure and annotations}{index-annotations}

Internally, the Index Checker computes information about integers that
might be indices:
\begin{itemize}
\item
  the lower bound on an integer, such as whether it is known to be positive
  (Section~\ref{index-lowerbound})
\item
  the upper bound on an integer, such as whether it is less than the length
  of a given sequence (Section~\ref{index-upperbound})
\item
  whether an integer came from calling the JDK's binary search routine on
  an array (Section~\ref{index-searchindex})
\item
  whether an integer came from calling a string search routine
  (Section~\ref{index-substringindex})
\end{itemize}

\noindent
and about sequence lengths:
\begin{itemize}
\item
  the minimum length of a sequence, such ``\<myArray> contains at least 3
  elements'' (Section~\ref{index-minlen})
\item
  whether two sequences have the same length (Section~\ref{index-samelen})
\end{itemize}

The Index Checker checks of all these properties at once, but
this manual discusses each type system in a different section.
There are some annotations that are shorthand for writing multiple
annotations, each from a different type system:

\begin{description}
\item[\refqualclasswithparams{checker/index/qual}{IndexFor}{String[] names}]
  The value is a valid index for the named sequences.  For example, the
  \sunjavadoc{java.base/java/lang/String.html\#charAt(int)}{String.charAt(int)}
  method is declared as

  \begin{Verbatim}
  class String {
    char charAt(@IndexFor("this") int index) { ... }
  }
  \end{Verbatim}

  More generally, a variable
  declared as \<@IndexFor("someArray") int i> has type
  \<@IndexFor("someArray") int> and its run-time value is guaranteed to be
  non-negative and less than the length of \<someArray>.  You could also
  express this as
  \<\refqualclass{checker/index/qual}{NonNegative}
  \refqualclasswithparams{checker/index/qual}{LTLengthOf}{"someArray"}
  int i>,
  but \<@IndexFor("someArray") int i> is more concise.

 \item[\refqualclasswithparams{checker/index/qual}{IndexOrHigh}{String[] names}]
   The value is non-negative and is less than or equal to the length of
   each named sequence.  This type combines
  \refqualclass{checker/index/qual}{NonNegative} and
  \refqualclass{checker/index/qual}{LTEqLengthOf}.

  For example, the
  \sunjavadoc{java.base/java/util/Arrays.html\#fill(java.lang.Object\%5B\%5D,int,int,java.lang.Object)}{Arrays.fill}
   method is declared as

  \begin{mysmall}
  \begin{Verbatim}
  class Arrays {
    void fill(Object[] a, @IndexFor("#1") int fromIndex, @IndexOrHigh("#1") int toIndex, Object val)
  }
  \end{Verbatim}
  \end{mysmall}

 \item[\refqualclasswithparams{checker/index/qual}{LengthOf}{String[] names}]
   The value is exactly equal to the length of the named
   sequences. In the implementation, this type aliases
   \refqualclass{checker/index/qual}{IndexOrHigh}, so writing it
   only adds documentation (although future versions of the Index Checker
   may use it to improve precision).

 \item[\refqualclasswithparams{checker/index/qual}{IndexOrLow}{String[] names}]
   The value is -1 or is a valid index for
   each named sequence.  This type combines
  \refqualclass{checker/index/qual}{GTENegativeOne} and
  \refqualclass{checker/index/qual}{LTLengthOf}.

%  Example commented out; IndexOrLow is not sound for indexOf, because "".indexOf("") returns 0
%
%  For example, the
%  \sunjavadoc{java.base/java/lang/String.html\#indexOf(java.lang.String)}{String.indexOf(String)}
%  method is declared as
%
%  \begin{Verbatim}
%  class String {
%    @IndexOrLow("this") int indexOf(String str) { ... }
%  }
%  \end{Verbatim}

 \item[\refqualclass{checker/index/qual}{PolyIndex}]
   indicates qualifier polymorphism.  This type combines
   \refqualclass{checker/index/qual}{PolyLowerBound} and
   \refqualclass{checker/index/qual}{PolyUpperBound}.
   For a description of qualifier polymorphism, see
   Section~\ref{method-qualifier-polymorphism}.

 \item[\refqualclass{checker/index/qual}{PolyLength}]
   is a special polymorphic qualifier that combines
   \refqualclass{checker/index/qual}{PolySameLen} and
   \refqualclass{common/value/qual}{PolyValue} from the
   Constant Value Checker (see \chapterpageref{constant-value-checker}).
   \refqualclass{checker/index/qual}{PolyLength} exists
   as a shorthand for these two annotations, since
   they often appear together.

\end{description}

\sectionAndLabel{Lower bounds}{index-lowerbound}

The Index Checker issues an error when
a sequence is indexed by an integer that might be negative.
The Lower Bound Checker uses a type system (Figure~\ref{fig-index-int-types}) with the following
qualifiers:

\begin{description}
\item[\refqualclass{checker/index/qual}{Positive}]
  The value is 1 or greater, so it is not too low to be used as an index.
  Note that this annotation is trusted by the Constant Value Checker,
  so if the Constant Value Checker is run on code containing this annotation,
  the Lower Bound Checker must be run on the same code in order to
  guarantee soundness.
\item[\refqualclass{checker/index/qual}{NonNegative}]
  The value is 0 or greater, so it is not too low to be used as an index.
\item[\refqualclass{checker/index/qual}{GTENegativeOne}]
  The value is -1 or greater.
  It may not be used as an index for a sequence, because it might be too low.
  (``\<GTE>'' stands for ``Greater Than or Equal to''.)
\item[\refqualclass{checker/index/qual}{PolyLowerBound}]
  indicates qualifier polymorphism.
  For a description of qualifier polymorphism, see
  Section~\ref{method-qualifier-polymorphism}.
\item[\refqualclass{checker/index/qual}{LowerBoundUnknown}]
  There is no information about the value.
  It may not be used as an index for a sequence, because it might be too low.
\item[\refqualclass{checker/index/qual}{LowerBoundBottom}]
    The value cannot take on any integral types. The bottom type, which
    should not need to be written by the programmer.
\end{description}

\begin{figure}
\begin{center}
  \hfill
  \includeimagenocentering{lowerbound}{5cm}
  ~~~~\hfill~~~~
  \includeimagenocentering{upperbound}{7cm}
  \hfill
\end{center}
  \caption{The two type hierarchies for integer types used by the Index
    Checker.  On the left is a type system for lower bounds.  On the right
    is a type system for upper bounds.  Qualifiers written in gray should
    never be written in source code; they are used internally by the type
    system.
    % Using "\\" works for some but not all installations of LaTeX.
    \newline
    In the Upper Bound type system, subtyping rules depend on both the
    array name (\<"myArray">, in the figure) and on the offset (which is 0,
    the default, in the figure).  Another qualifier is
    \refqualclass{checker/index/qual}{UpperBoundLiteral}, whose subtyping
    relationships depend on its argument and on offsets for other qualifiers.
 }
  \label{fig-index-int-types}
\end{figure}


\sectionAndLabel{Upper bounds}{index-upperbound}

The Index Checker issues an error when a sequence index might be
too high. To do this, it maintains information about which expressions are
safe indices for which sequences.
The length of a sequence is \code{arr.length} for arrays and
\code{str.length()} for strings.
It uses a type system (Figure~\ref{fig-index-int-types}) with the following
qualifiers:

It issues an error when a sequence \code{arr}
is indexed by an integer that is not of type \code{@LTLengthOf("arr")}
or \code{@LTOMLengthOf("arr")}.

\begin{description}

\item[\refqualclasswithparams{checker/index/qual}{LTLengthOf}{String[] names, String[] offset}]
  An expression with this type
  has value less than the length of each sequence listed in \<names>.
  The expression may be used as an index into any of those sequences,
  if it is non-negative.
  For example, an expression of type \code{@LTLengthOf("a") int} might be
  used as an index to \<a>.
  The type \code{@LTLengthOf(\{"a", "b"\})} is a subtype of both
  \code{@LTLengthOf("a")} and \code{@LTLengthOf("b")}.
  (``\<LT>'' stands for ``Less Than''.)

  \<@LTLengthOf> takes an optional \<offset> element, meaning that the
  annotated expression plus the offset is less than the length of the given
  sequence.  For example, suppose expression \<e> has type \<@LTLengthOf(value
  = \{"a", "b"\}, offset = \{"-1", "x"\})>. Then \<e - 1> is less than
  \<a.length>, and \<e + x> is less than \<b.length>.  This helps to make
  the checker more precise.  Programmers rarely need to write the \<offset>
  element.

\item[\refqualclasswithparams{checker/index/qual}{LTEqLengthOf}{String[] names}]
  An expression with this type
  has value less than or equal to the length of each sequence listed in \<names>.
  It may not be used as an index for these sequences, because it might be too high.
  \code{@LTEqLengthOf(\{"a", "b"\})} is a subtype of both
  \code{@LTEqLengthOf("a")} and \code{@LTEqLengthOf("b")}.
  (``\<LTEq>'' stands for ``Less Than or Equal to''.)

  \<@LTEqLengthOf(\{"a"\})> = \<@LTLengthOf(value=\{"a"\}, offset=-1)>, and \\
  \<@LTEqLengthOf(value=\{"a"\}, offset=x)> = \<@LTLengthOf(value=\{"a"\},
  offset=x-1)> for any x.

\item[\refqualclasswithparams{checker/index/qual}{LTOMLengthOf}{String[] names}]
  An expression with this type
  has value at least 2 less than the length of each sequence listed in \<names>.
  It may always used as an index for a sequence listed in \<names>, if it is
  non-negative.

  This type exists to allow the checker to infer the safety of loops of
  the form:
\begin{Verbatim}
  for (int i = 0; i < array.length - 1; ++i) {
    arr[i] = arr[i+1];
  }
\end{Verbatim}
  This annotation should rarely (if ever) be written by the programmer; usually
  \refqualclasswithparams{checker/index/qual}{LTLengthOf}{String[] names}
  should be written instead.
  \code{@LTOMLengthOf(\{"a", "b"\})} is a subtype of both
  \code{@LTOMLengthOf("a")} and \code{@LTOMLengthOf("b")}.
  (``\<LTOM>'' stands for ``Less Than One Minus'', because another way of
  saying ``at least 2 less than \<a.length>'' is ``less than \<a.length-1>''.)

  \<@LTOMLengthOf(\{"a"\})> = \<@LTLengthOf(value=\{"a"\}, offset=1)>, and \\
  \<@LTOMLengthOf(value=\{"a"\}, offset=x)> = \<@LTLengthOf(value=\{"a"\},
  offset=x+1)> for any x.

\item[\refqualclass{checker/index/qual}{UpperBoundLiteral}]
  represents a constant value, typically a literal written in source code.
  Its subtyping relationship is:
  \<@UpperBoundLiteral(lit)> <: \<LTLengthOf(value="myArray", offset=off)>
  if \<lit>+\<offset> $\le$ -1.

\item[\refqualclass{checker/index/qual}{PolyUpperBound}]
  indicates qualifier polymorphism.
  For a description of qualifier polymorphism, see
  Section~\ref{method-qualifier-polymorphism}.

\item[\refqualclass{checker/index/qual}{UpperBoundUnknown}]
  There is no information about the upper bound on the value of an expression with this type.
  It may not be used as an index for a sequence, because it might be too high.
  This type is the top type, and should never need to be written by the
  programmer.

\item[\refqualclass{checker/index/qual}{UpperBoundBottom}]
  This is the bottom type for the upper bound type system. It should
  never need to be written by the programmer.

\end{description}

The following method annotations can be used to establish a method postcondition
that ensures that a certain expression is a valid index for a sequence:

\begin{description}
\item[\refqualclasswithparams{checker/index/qual}{EnsuresLTLengthOf}{String[] value, String[] targetValue, String[] offset}]
  When the method with this annotation returns, the expression (or all the expressions) given in the \code{value} element
  is less than the length of the given sequences with the given offsets. More precisely, the expression
  has the \code{@LTLengthOf} qualifier with the \code{value} and \code{offset} arguments
  taken from the \code{targetValue} and \code{offset} elements of this annotation.
\item[\refqualclasswithparams{checker/index/qual}{EnsuresLTLengthOfIf}{String[] expression, boolean result, String[] targetValue, String[] offset}]
  If the method with this annotation returns the given boolean value,
  then the given expression (or all the given expressions)
  is less than the length of the given sequences with the given offsets.
\end{description}

There is one declaration annotation that indicates the relationship between
two sequences:

\begin{description}
\item[\refqualclasswithparams{checker/index/qual}{HasSubsequence}{String[]
    value, String[] from, String[] to}]
  indicates that a subsequence (from \code{from} to \code{to}) of the
  annotated sequence is equal to some other sequence, named by
  \code{value}).

For example, to indicate that \<shorter> is a subsequence of \<longer>:

\begin{Verbatim}
  int start;
  int end;
  int[] shorter;
  @HasSubsequence(value="shorter", from="this.start", to="this.end")
  int[] longer;
\end{Verbatim}

Thus, a valid index into \<shorter> is also a valid index (between
\code{start} and \code{end-1} inclusive) into \<longer>.  More generally,
if \code{x} is \code{@IndexFor("shorter")} in the example above, then
\code{start + x} is \code{@IndexFor("longer")}. If \code{y} is
\code{@IndexFor("longer")} and \code{@LessThan("end")}, then \code{y -
  start} is \code{@IndexFor("shorter")}. Finally, \code{end - start} is
\code{@IndexOrHigh("shorter")}.

This annotation is in part checked and in part trusted.  When an array is
assigned to \code{longer}, three facts are checked: that \code{start} is
non-negative, that \code{start} is less than or equal to \code{end}, and
that \code{end} is less than or equal to the length of \code{longer}.  This
ensures that the indices are valid. The programmer must manually verify
that the value of \code{shorter} equals the subsequence that they describe.
\end{description}


\sectionAndLabel{Sequence minimum lengths}{index-minlen}

The Index Checker estimates, for each sequence expression, how long its value
might be at run time by computing a minimum length that
the sequence is guaranteed to have.  This enables the Index Checker to
verify indices that are compile-time constants.  For example, this code:

\begin{Verbatim}
  String getThirdElement(String[] arr) {
    return arr[2];
  }
\end{Verbatim}

\noindent
is legal if \<arr> has at least three elements, which can be indicated
in this way:

\begin{Verbatim}
  String getThirdElement(String @MinLen(3) [] arr) {
    return arr[2];
  }
\end{Verbatim}

When the index is not a compile-time constant, as in \<arr[i]>, then the
Index Checker depends not on a \<@MinLen> annotation but on \<i> being
annotated as
\refqualclasswithparams{checker/index/qual}{LTLengthOf}{"arr"}.

The MinLen type qualifier is implemented in practice by the Constant Value Checker,
using \<@ArrayLenRange> annotations (see \chapterpageref{constant-value-checker}).
This means that errors related to the minimum lengths of arrays must be suppressed using
the "value" argument to \<@SuppressWarnings>.
\refqualclass{common/value/qual}{ArrayLenRange} and \refqualclass{common/value/qual}{ArrayLen}
annotations can also be used to establish the minimum length of a sequence, if a
more precise estimate of length is known. For example,
if \<arr> is known to have exactly three elements:

\begin{Verbatim}
  String getThirdElement(String @ArrayLen(3) [] arr) {
    return arr[2];
  }
\end{Verbatim}

The following type qualifiers (from \chapterpageref{constant-value-checker})
can establish the minimum length of a sequence:

\begin{description}
\item[\refqualclasswithparams{common/value/qual}{MinLen}{int value}]
  The value of an expression of this type is a sequence with at least
  \code{value} elements.  The default annotation is
  \code{@MinLen(0)}, and it may be applied to non-sequences.
  \code{@MinLen($x$)} is a subtype of \code{@MinLen($x-1$)}.
  An \code{@MinLen} annotation is treated internally as an
  \refqualclass{common/value/qual}{ArrayLenRange} with only its
  \code{from} field filled.
\item[\refqualclasswithparams{common/value/qual}{ArrayLen}{int[] value}]
  The value of an expression of this type is a sequence whose
  length is exactly one of the integers listed in its argument.
  The argument can contain at most ten integers; larger collections of
  integers are converted to \refqualclass{common/value/qual}{ArrayLenRange}
  annotations. The minimum length of a sequence with this annotation
  is the smallest element of the argument.
\item[\refqualclasswithparams{common/value/qual}{ArrayLenRange}{int from, int to}]
  The value of an expression of this type is a sequence whose
  length is bounded by its arguments, inclusive.
  The minimum length of a sequence with this annotation is its \<from> argument.
\end{description}

\begin{figure}
\begin{center}
  \hfill
  \includeimage{samelen}{5cm}
  \hfill
\end{center}
  \caption{The type hierarchy for arrays of equal length ("a" and "b" are
    assumed to be in-scope sequences).  Qualifiers
    written in gray should never be written in source code; they are used
    internally by the type system.}
  \label{fig-index-array-types}
\end{figure}

The following method annotation can be used to establish a method postcondition
that ensures that a certain sequence has a minimum length:

\begin{description}
\item[\refqualclasswithparams{common/value/qual}{EnsuresMinLenIf}{String[] expression, boolean result, int targetValue}]
  If the method with this annotation returns the given boolean value,
  then the given expression (or all the given expressions) is a sequence
  with at least \code{targetValue} elements.
\end{description}

\sectionAndLabel{Sequences of the same length}{index-samelen}

The Index Checker determines whether two or more sequences have the same length.
This enables it to verify that all the indexing operations are safe in code
like the following:

\begin{Verbatim}
  boolean lessThan(double[] arr1, double @SameLen("#1") [] arr2) {
    for (int i = 0; i < arr1.length; i++) {
      if (arr1[i] < arr2[i]) {
        return true;
      } else if (arr1[i] > arr2[i]) {
        return false;
      }
    }
    return false;
  }
\end{Verbatim}

When needed, you can specify which sequences have the same length using the following type qualifiers (Figure~\ref{fig-index-array-types}):

\begin{description}
\item[\refqualclasswithparams{checker/index/qual}{SameLen}{String[] names}]
  An expression with this type represents a sequence that has the
  same length as the other sequences named in \<names>. In general,
  \code{@SameLen} types that have non-intersecting sets of names
  are \textit{not} subtypes of each other. However, if at least one
  sequence is named by both types, the types are actually the same,
  because all the named sequences must have the same length.
\item[\refqualclass{checker/index/qual}{PolySameLen}]
  indicates qualifier polymorphism.
  For a description of qualifier polymorphism, see
  Section~\ref{method-qualifier-polymorphism}.
\item[\refqualclass{checker/index/qual}{SameLenUnknown}]
  No information is known about which other sequences have the same length
  as this one.
  This is the top type, and programmers should never need to write it.
\item[\refqualclass{checker/index/qual}{SameLenBottom}]
  This is the bottom type, and programmers should rarely need to write it.
  \code{null} has this type.
\end{description}


\sectionAndLabel{Binary search indices}{index-searchindex}

The JDK's
\sunjavadoc{java.base/java/util/Arrays.html\#binarySearch(java.lang.Object\%5B\%5D,java.lang.Object)}{Arrays.binarySearch}
method returns either where the value was found, or a negative value
indicating where the value could be inserted.  The Search Index Checker
represents this concept.

\begin{figure}
\begin{center}
  \hfill
  \includeimage{searchindex}{7cm}
  \hfill
\end{center}
  \caption{The type hierarchy for the Index Checker's internal type system
  that captures information about the results of calls to
  \sunjavadoc{java.base/java/util/Arrays.html\#binarySearch(java.lang.Object\%5B\%5D,java.lang.Object)}{Arrays.binarySearch}.}
  \label{fig-index-searchindex}
\end{figure}

The Search Index Checker's type hierarchy (Figure~\ref{fig-index-searchindex}) has four type qualifiers:
\begin{description}
\item[\refqualclasswithparams{checker/index/qual}{SearchIndexFor}{String[] names}]
  An expression with this type represents an integer that could have been
  produced by calling
  \sunjavadoc{java.base/java/util/Arrays.html\#binarySearch(java.lang.Object\%5B\%5D,java.lang.Object)}{Arrays.binarySearch}:
  for each array \<a> specified in the annotation, the annotated integer is
  between \<-a.length-1> and \<a.length-1>, inclusive
\item[\refqualclasswithparams{checker/index/qual}{NegativeIndexFor}{String[] names}]
  An expression with this type represents a ``negative index'' that is
  between \<a.length-1> and \<-1>, inclusive; that is, a value that is both
  a \<@SearchIndex> and is negative.  Applying the bitwise complement
  operator (\verb|~|) to an expression of this type produces an expression
  of type \refqualclass{checker/index/qual}{IndexOrHigh}.
\item[\refqualclass{checker/index/qual}{SearchIndexBottom}]
  This is the bottom type, and programmers should rarely need to write it.
\item[\refqualclass{checker/index/qual}{SearchIndexUnknown}]
  No information is known about whether this integer is a search index.
  This is the top type, and programmers should rarely need to write it.
\end{description}


\sectionAndLabel{Substring indices}{index-substringindex}

The methods
\sunjavadoc{java.base/java/lang/String.html\#indexOf(java.lang.String)}{String.indexOf}
and
\sunjavadoc{java.base/java/lang/String.html\#lastIndexOf(java.lang.String)}{String.lastIndexOf}
return an index of a given substring within a given string, or -1 if no
such substring exists.  The index \<i> returned from
\<receiver.indexOf(substring)> satisfies the following property, which is
stated here in three equivalent ways:
\begin{Verbatim}
 i == -1 || ( i >= 0       && i <= receiver.length() - substring.length()                  )
 i == -1 || ( @NonNegative && @LTLengthOf(value="receiver", offset="substring.length()-1") )
 @SubstringIndexFor(value="receiver", offset="substring.length()-1")
\end{Verbatim}

% This new annotation is similar to \<@LTLengthOf\allowbreak(value =
% "receiver", offset = "substring.length()-1")>, but explicitly allows the
% index to be -1 even if the upper bound would not allow it because of the
% offset.  The Upper Bound Checker can infer the corresponding
% \<@LTLengthOf> annotation for expressions that have a
% \<@SubstringIndexFor> annotation and at the same time are known to be
% non-negative (according to the Lower Bound Checker).

The return type of methods \sunjavadoc{java.base/java/lang/String.html\#indexOf(java.lang.String)}{String.indexOf}
and \sunjavadoc{java.base/java/lang/String.html\#lastIndexOf(java.lang.String)}{String.lastIndexOf} has the annotation
\refqualclasswithparams{checker/index/qual}{SubstringIndexFor}{value="this", offset="\#1.length()-1")}.
This allows writing code such as the following with no warnings from the
Index Checker:

\begin{Verbatim}
  public static String removeSubstring(String original, String removed) {
    int i = original.indexOf(removed);
    if (i != -1) {
      return original.substring(0, i) + original.substring(i + removed.length());
    }
    return original;
  }
\end{Verbatim}

% The code removes the first occurrence of \<removed> from
% \<original>. After checking that \code{i != -1}, the value of \<i> must
% be a valid index for \<original>. Because this index is the start of an
% occurrence of \<removed>, \code{i + removed.length()} is the index of the
% end of the occurrence.  Without the \<@SubstringIndexFor> annotation, the
% Upper Bound Checker would not be able to verify that \code{i +
% removed.length()} is a valid argument to \<substring>, which requires
% both arguments to be \<@IndexOrHigh("original")>.

\begin{figure}
\begin{center}
  \hfill
  \includeimage{substringindex}{3.5cm}
  \hfill
\end{center}
  \caption{The type hierarchy for the Substring Index Checker, which
    captures information about the results of calls to
    \sunjavadoc{java.base/java/lang/String.html\#indexOf(java.lang.String)}{String.indexOf}
    and
    \sunjavadoc{java.base/java/lang/String.html\#lastIndexOf(java.lang.String)}{String.lastIndexOf}.}
  \label{fig-index-substringindex}
\end{figure}

The \<@SubstringIndexFor> annotation is implemented in a Substring Index
Checker that runs together with the Index Checker and has its own type
hierarchy (Figure~\ref{fig-index-substringindex}) with three type
qualifiers:
\begin{description}
\item[\refqualclasswithparams{checker/index/qual}{SubstringIndexFor}{String[] value, String[] offset}]
  An expression with this type represents an integer that could have been
  produced by calling
  \sunjavadoc{java.base/java/lang/String.html\#indexOf(java.lang.String)}{String.indexOf}:
  the annotated integer is either -1, or it is non-negative and is less
  than or equal to \<receiver.length - offset> (where the sequence
  \<receiver> and the offset \<offset> are corresponding elements of the
  annotation's arguments).
\item[\refqualclass{checker/index/qual}{SubstringIndexBottom}]
  This is the bottom type, and programmers should rarely need to write it.
\item[\refqualclass{checker/index/qual}{SubstringIndexUnknown}]
  No information is known about whether this integer is a substring index.
  This is the top type, and programmers should rarely need to write it.
\end{description}


\subsectionAndLabel{The need for the \<@SubstringIndexFor> annotation}{index-substringindex-justification}

No other annotation supported by the Index Checker precisely represents the
possible return values of methods
\sunjavadoc{java.base/java/lang/String.html\#indexOf(java.lang.String)}{String.indexOf}
and
\sunjavadoc{java.base/java/lang/String.html\#lastIndexOf(java.lang.String)}{String.lastIndexOf}.
The reason is the methods' special cases for empty strings and for failed matches.

Consider the result \<i> of \<receiver.indexOf(substring)>:

\begin{itemize}
\item
  \<i> is \<@GTENegativeOne>, because \code{i >= -1}.
\item
  \<i> is \<@LTEqLengthOf("receiver")>, because \code{i <= receiver.length()}.
\item
  \<i> is not \<@IndexOrLow("receiver")>, because for
  \code{receiver = "", substring = "", i = 0}, the property
  \code{i >= -1 \&\& i < receiver.length()} does not hold.
\item
  \<i> is not \<@IndexOrHigh("receiver")>, because for
  \code{receiver = "", substring = "b", i = -1}, the property
  \code{i >= 0 \&\& i <= receiver.length()} does not hold.
\item
  \<i> is not
  \<@LTLengthOf(value = "receiver", offset = "substring.length()-1")>,
  because for \code{receiver = "", substring = "abc", i = -1}, the property
  \code{i + substring.length() - 1 < receiver.length()} does not hold.
\end{itemize}

\noindent
The last annotation in the list above,
\<@LTLengthOf(value = "receiver", offset = "substring.length()-1")>,
is the correct and precise upper bound for all values of \<i> except -1.
The offset expresses the fact that we can add \<substring.length()> to this
index and still get a valid index for \<receiver>.  That is useful for
type-checking code that adds the length of the substring to the found
index, in order to obtain the rest of the string.  However, the upper bound
applies only after the index is explicitly checked not to be -1:

\begin{Verbatim}
  int i = receiver.indexOf(substring);
  // i is @GTENegativeOne and @LTEqLengthOf("receiver")
  // i is not @LTLengthOf(value = "receiver", offset = "substring.length()-1")
  if (i != -1) {
    // i is @NonNegative and @LTLengthOf(value = "receiver", offset = "substring.length()-1")
    int j = i + substring.length();
    // j is @IndexOrHigh("receiver")
    return receiver.substring(j); // this call is safe
  }
\end{Verbatim}

The property of the result of \<indexOf> cannot be expressed by any
combination of lower-bound (Section~\ref{index-lowerbound}) and upper-bound
(Section~\ref{index-upperbound}) annotations, because the upper-bound
annotations apply independently of the lower-bound annotations, but in this
case, the upper bound \code{i <= receiver.length() - substring.length()}
holds only if \code{i >= 0}.  Therefore, to express this property and make
the example type-check without false positives, a new annotation such as
\<@SubstringIndexFor\allowbreak(value = "receiver", offset = "substring.length()-1")>
is necessary.

\sectionAndLabel{Inequalities}{index-inequalities}

The Index Checker estimates which expression's values are less than other expressions' values.

\begin{description}

\item[\refqualclasswithparams{checker/index/qual}{LessThan}{String[] values}]
  An expression with this type has a value that is less than the value of each
  expression listed in \<values>. The expressions in values must be composed of
  final or effectively final variables and constants.

\item[\refqualclass{checker/index/qual}{LessThanUnknown}]
  There is no information about the value of an expression this type relative to other expressions.
  This is the top type, and should not be written by the programmer.

 \item[\refqualclass{checker/index/qual}{LessThanBottom}]
   This is the bottom type for the less than type system. It should
   never need to be written by the programmer.

\end{description}

\sectionAndLabel{Annotating fixed-size data structures}{index-annotating-fixed-size}

The Index Checker has built-in support for Strings and arrays.
You can add support for additional fixed-size data structures by writing
annotations.
This allows the Index Checker to typecheck the data structure's
implementation and to typecheck uses of the class.

This section gives an example:  a fixed-length collection.

%% The code that follows is copied from checker/tests/index/ArrayWrapper.java.
%% If this code is updated, please update that file, too.

\begin{Verbatim}
/** ArrayWrapper is a fixed-size generic collection. */
public class ArrayWrapper<T> {
    private final Object @SameLen("this") [] delegate;

    @SuppressWarnings("index") // constructor creates object of size @SameLen(this) by definition
    ArrayWrapper(@NonNegative int size) {
        delegate = new Object[size];
    }

    public @LengthOf("this") int size() {
        return delegate.length;
    }

    public void set(@IndexFor("this") int index, T obj) {
        delegate[index] = obj;
    }

    @SuppressWarnings("unchecked") // required for normal Java compilation due to unchecked cast
    public T get(@IndexFor("this") int index) {
        return (T) delegate[index];
    }
}
\end{Verbatim}

The Index Checker treats methods annotated with \code{@LengthOf("this")}  as
the length of a sequence like \code{arr.length} for arrays and
\code{str.length()} for strings.

With these annotations, client code like the following typechecks with no
warnings:
\begin{Verbatim}
    public static void clearIndex1(ArrayWrapper<? extends Object> a, @IndexFor("#1") int i) {
        a.set(i, null);
    }

    public static void clearIndex2(ArrayWrapper<? extends Object> a, int i) {
        if (0 <= i && i < a.size()) {
            a.set(i, null);
        }
    }
\end{Verbatim}


\sectionAndLabel{Support for mutable-length data structures}{index-mutable-length}

The Index Checker was originally limited to \emph{fixed-size} sequences whose
lengths never change after creation. However, many real-world collections
(e.g., {\tt List} or other containers) can grow or shrink at runtime.
This section extends the Index Checker to handle such \emph{mutable-length} data
structures, addressing the challenges of mutation and aliasing. In particular,
we permit certain safe mutations (like growing a collection) while restricting or
carefully checking mutations that shrink a collection’s length, in order to
preserve index safety.

\subsectionAndLabel{The challenges of mutation and aliasing}{index-mutable-overview}

When a collection’s length can change, an index that was valid at one point may
become invalid later. For example, if an element is removed from a list after
an index is verified, that index might now be out of bounds. The core problem is
that \textbf{shrinking} a collection invalidates earlier index assumptions.
Aliasing exacerbates this – if multiple references point to the same collection,
a mutation via one reference can affect the others. The current Index Checker
assumes no aliasing or length changes, so it would incorrectly treat a
previously-validated index as safe even after the collection has shrunk.

To maintain soundness, the extended Index Checker must treat certain operations
as potential invalidations of index information. The key insight is that
\textbf{growing} a collection (adding elements) never invalidates existing indices
(any index valid before remains valid after an increase in length), whereas
\textbf{shrinking} a collection (removing elements) can render previously valid
indices too high. Therefore, the type system distinguishes situations where length
decreases are possible from those where they are not, and it invalidates (forgets)
index facts upon operations that could reduce a collection’s length or otherwise
disrupt earlier assumptions.

\subsectionAndLabel{Permitting growth and restricting shrinking}{index-mutable-approach}

The extended Index Checker’s approach is to allow mutations that increase length
with minimal overhead, while placing restrictions on operations that might decrease
length. In practice, this means a programmer can freely append to a collection without
breaking index safety, but removals must be tracked and often require revalidation of
indices. We introduce a set of type qualifiers on collection references that encode
what mutations are permitted through that reference. By writing these annotations
in your code (or relying on defaults), you communicate to the type checker which
references will be used to modify lengths and how.

In essence, a reference to a mutable collection can be in one of several “modes”:
\begin{itemize}
\item
  A reference that is used only for reading or growing the collection
  (never to remove elements) can be treated almost like a fixed-size collection,
  since it will never witness a length-decreasing mutation.
\item
  A reference through which elements may be removed (shrinking the collection)
  is considered more volatile – the checker must enforce additional checks and
  may invalidate some facts after mutations.
\item
  In special cases, a programmer can declare that a reference’s mutations are not
  being checked for index safety (opting out for difficult scenarios or incremental
  adoption).
\end{itemize}

By permitting some references to only grow (or not mutate at all) and requiring
explicit annotation for those that can shrink, the type system ensures that any
potential unsafe scenario (like using an index after an element removal) is either
prevented or re-checked. We next define the qualifier hierarchy that implements
these ideas.

\subsectionAndLabel{Qualifier hierarchy for mutable-length collections}{index-mutable-qualifiers}

Four new type qualifiers describe how a reference to a sequence can be used with
respect to length mutations. They form a qualifier hierarchy that the checker
enforces on assignments and method calls. The qualifiers are:
\footnote{These annotations apply to references of sequence types
(e.g., \code{List<E>}, arrays, etc.) that are subject to index checking.}

\begin{description}
\item[\refqualclass{checker/index/qual}{UnShrinkableRef}]
  Indicates that this reference will not be used to shrink the collection. In other
  words, calling methods that remove elements (such as \code{remove()} or \code{clear()})
  through this reference is forbidden. However, the collection \emph{could} still be
  modified by other aliases. An @UnShrinkableRef reference guarantees that as long as
  this reference is used exclusively, the collection’s size will not decrease. This is
  the \textbf{default qualifier} for mutable-length structures: if no annotation is written,
  a reference is assumed to be @UnShrinkableRef. It places a restriction on the
  \emph{current reference’s} usage (no removal through it) but does \emph{not} promise
  that the collection’s size cannot change via other references. The Index Checker will
  thus allow index-safe operations under the assumption that this reference doesn’t shrink
  the sequence, but it remains cautious about possible external mutations (see aliasing below).

\item[\refqualclass{checker/index/qual}{GrowOnly}]
  A stronger qualifier that indicates the reference will be used only to \emph{grow}
  the collection and not to shrink it. Like @UnShrinkableRef, it forbids calling any
  shrinking methods through this reference. In addition, @GrowOnly implies that no other
  alias will shrink the collection while this reference is alive. In effect, the
  collection’s length can only stay the same or increase. This means any index that is
  valid at one point remains valid later (unless the index itself is reassigned). The
  type system ensures that a @GrowOnly reference cannot coexist (alias) with any reference
  that permits shrinking. Using a @GrowOnly reference, one can safely append to a collection
  without invalidating existing index relationships, and the checker will not unnecessarily
  invalidate index information on that reference after additions. (Any attempt to call a
  removal method on a @GrowOnly reference is a type error.)

\item[\refqualclass{checker/index/qual}{Shrinkable}]
  Indicates that this reference may be used to shrink the collection (e.g., via removals).
  When a reference is @Shrinkable, the Index Checker allows calls to element-removing methods
  through it. However, because such calls can reduce the length, the checker takes extra
  precautions: it will typically require that code re-establish index bounds after a mutation,
  and it will *invalidate any previously inferred index facts* for this collection when a shrink
  operation occurs. In other words, after a removal, the checker treats the size and safe indices
  of the collection as potentially changed (unless proven otherwise by new checks). A @Shrinkable reference also signifies that other aliases might shrink the collection as well. The presence of a @Shrinkable reference is what truly marks a data structure as mutable-length from the checker’s perspective, so it is used only when needed. In practice, you should annotate a variable as @Shrinkable if you intend to call methods that remove elements through it (or pass it to code that might do so). All @Shrinkable references are considered supertype-compatible with @UnShrinkableRef (meaning you can use a shrinkable collection in a context that doesn’t remove elements), but not vice versa.

\item[\refqualclass{checker/index/qual}{UncheckedShrinkable}]
  This qualifier also permits shrinking, but it signals the type checker to \emph{opt out} of
  index safety guarantees for this reference. In effect, @UncheckedShrinkable tells the checker,
  “assume all indices are valid, even across mutations.” It is an escape hatch for cases where
  the aliasing or mutation patterns are too complex for the current type system, or during
  incremental adoption of the checker. You should rarely use this qualifier in application code —
  it’s mainly provided for situations where full checking is impractical. A reference annotated
  @UncheckedShrinkable is treated as potentially shrinkable, but the checker will not issue
  warnings for index operations on it (making it the programmer’s responsibility to ensure safety).
  Internally, @UncheckedShrinkable can be thought of as a subtype of @Shrinkable that disables
  warnings. It can be freely cast to @Shrinkable or vice versa when needed, but doing so means
  relinquishing or reinstating compile-time guarantees.  (Using @UncheckedShrinkable is analogous
  to using a @SuppressWarnings in that it trades soundness for expedience.)

\item[\refqualclass{checker/index/qual}{BottomGrowShrink}]
  This is the bottom qualifier in the mutable-length collection hierarchy. It is used
  internally by the type system to represent the most restrictive reference — one that
  permits neither growth nor shrinking of a collection. This qualifier is not intended
  to be written in source code and will typically only appear in diagnostics or in
  subtyping relationships as part of type inference. As with other bottom types such as
  \refqualclass{checker/index/qual}{LowerBoundBottom} or
  \refqualclass{checker/index/qual}{UpperBoundBottom}, its main role is to serve as
  the subtype of all other mutability qualifiers. The type system ensures that no
  reference in a user program will be assigned this type, and it should never be used
  explicitly in annotations.
\end{description}

These qualifiers work together to enforce safe patterns. The qualifier hierarchy
(shown schematically in Figure 11.10) has @UnShrinkableRef as its top (most general) type,
since any reference that promises not to shrink the collection can be treated as an
@UnShrinkableRef. Both @Shrinkable and @GrowOnly are sub-types of @UnShrinkableRef –
they add stronger conditions (allowing or disallowing certain mutations). In the hierarchy,
@GrowOnly is incompatible with @Shrinkable (neither is a subtype of the other); they represent
distinct mutation permissions. The @UncheckedShrinkable qualifier is considered a subtype of
@Shrinkable (it is a special case of a shrinkable reference that bypasses checking). At the very
bottom is an implicit “bottom” qualifier that represents a reference that can neither grow nor
shrink – this is used internally by the type system and is not written by programmers.
Assignments and method calls must respect this hierarchy. For example, you can use a @Shrinkable
collection in any context that expects an @UnShrinkableRef (because a shrinkable collection can
certainly be used in a read-only way), but you cannot pass an @UnShrinkableRef where a @Shrinkable
is required (because the callee might attempt to remove an element). Likewise, the type system
prevents a @GrowOnly reference from being aliased by (or assigned to) a @Shrinkable reference,
since that would violate the guarantee that no shrink will occur.

\begin{figure}
\begin{center}
  \hfill
  \includeimage{index-mutability-lattice}{5cm}
  \hfill
\end{center}
  \caption{Qualifier hierarchy for Index Checker with mutable-length support.
    Arrows denote subtype relationships (lower means stricter/safer).}
  \label{index-mutability-lattice}
\end{figure}

\emph{Default behavior:} By default, the Index Checker treats unannotated collection references
as \refqualclass{checker/index/qual}{UnShrinkableRef}. This means that in typical code (without
new annotations), the checker assumes your code will not remove elements via those references.
This default was chosen because most collection operations are additions or reads; relatively
fewer places actually remove elements. If you do attempt to call a mutating method that shrinks
the collection without the reference being annotated as @Shrinkable (or @UncheckedShrinkable),
the checker will issue an error. In practice, you only need to add annotations in the parts of
your code that perform removals (or that need the special @GrowOnly or @UncheckedShrinkable
behavior). This default helps minimize the annotation burden while still catching places where
index safety could be compromised.

\subsectionAndLabel{Aliasing and effect annotations}{index-mutable-aliasing}

A critical aspect of supporting mutable-length structures is handling \textbf{aliasing}:
multiple references to the same collection. If one reference is used to shrink a collection,
other aliases to that collection must be aware that the length has changed. The extended Index
Checker uses a combination of type qualifiers and method annotations to account for aliasing:
\begin{itemize}
\item
  \textbf{Qualifiers prevent unsafe alias combinations:}
  The type hierarchy ensures that a @GrowOnly reference cannot exist at the same time as a
  @Shrinkable reference to the \emph{same} collection. If one part of the code treats a collection
  as grow-only, another part of the code cannot legally treat the same collection as shrinkable
  without a type error or explicit cast. This consistency check means that if you have a @GrowOnly
  List, you know no other part of the program is removing elements from it (otherwise the other
  part would have to be @Shrinkable and the checker would report a conflict). In contrast, an
  @UnShrinkableRef reference may alias a @Shrinkable one — which means the collection might be shrunk
  through the other alias. The checker will handle that scenario by invalidating index information (see below),
  but it does not prohibit the aliasing.

\item
  \textbf{The @BackedBy annotation:}
  To assist the checker in reasoning about two objects that share the same backing storage,
  we introduce an annotation \code{@BackedBy(<reference>)}. This is a class or method annotation
  that declares an aliasing relationship. For example, the \code{subList} method of \code{List}
  could be annotated to indicate that the returned list is backed by (and thus aliases) the original
  list. In code, it might look like:

\begin{Verbatim}
    public List<E> subList(int from, int to) @BackedBy("this");
\end{Verbatim}

  This means the result of \code{subList} is a view into the original list. The Index Checker uses
  @BackedBy information to propagate mutations: if a sub-list is modified (e.g., an element removed),
  the checker treats the original list’s length as changed as well. Without pointer analysis,
  these explicit alias annotations are crucial for soundness. They are used in library annotations
  to inform the checker of common aliasing patterns (views, wrappers, etc.). If your code uses a
  custom data structure where one collection is backed by another, you may use @BackedBy in a similar
  way.

\item
  \textbf{Method effects on length:}
  In order to know when to invalidate index-related facts, the checker must know which methods
  can change a collection’s length. Many standard methods (like \code{add}, \code{remove},
  \code{clear}, etc.) are obviously length-changing. The Checker Framework uses two mechanisms
  to handle this. First, it relies on the qualifier of the receiver or argument: for instance,
  calling \code{remove} on a @Shrinkable reference is understood to shrink the collection.
  Second, it provides a method annotation \code{@ChangesLength} to explicitly mark a method as
  modifying the length of a structure. For example, the \code{remove} method in \code{List} might
  be annotated as \code{@ChangesLength} (on the receiver), and a method like \code{Collections.shuffle(List)}
  could be annotated as \code{@ChangesLength("arg0")} if it may remove or add elements to its
  first argument. These annotations help the checker conservatively assume that after such a call,
  the length of the specified collection has changed (unless it can prove otherwise).
  In practice, the JDK’s annotated signatures use @ChangesLength on any method that can add or
  remove elements from a collection.

\item
  \textbf{Future pointer analysis:}
  Currently, the Index Checker does not perform whole-program pointer/alias analysis.
  It relies on the annotations described above to be informed of aliasing relationships and
  mutation effects. In the future, a pointer analysis could be integrated to automatically
  detect when two references might alias the same collection, or to determine more precisely
  which objects a given method might modify. This would reduce the need for manual @BackedBy
  annotations and could allow more fine-grained invalidation (for example, only dropping index
  facts for the specific collection that was mutated, rather than for all collections or all
  aliases). As of now, pointer analysis remains an area of future work; the present system
  strikes a balance by requiring the programmer to annotate tricky aliasing cases.
\end{itemize}

\subsectionAndLabel{Flow-sensitivity and side-effect invalidation}{index-mutable-flow}

Because of mutations, the Index Checker must sometimes forget (invalidate) information that was
established earlier in the code. The checker is \emph{flow-sensitive}: it tracks facts like
“\code{i} is a valid index for \code{list}” within a certain scope, but if something happens
that could falsify that fact, the checker will revoke it.

\textbf{Invalidation after side effects:}
If a reference is not known to be safe from shrinking (i.e., it is not @GrowOnly and not
explicitly opted-out), the checker takes a conservative approach: it
\textbf{invalidates all index-related qualifiers for that collection whenever a side effect may occur on it}.
In practice, this means that after any call to a method that might mutate the collection’s
length (or an alias of it), any previously inferred type like \code{@IndexFor("list")} or
\code{@LTLengthOf("list")} is cleared or downgraded. For example, consider this snippet:

\begin{Verbatim}
  // list is @Shrinkable List<String>
  if (0 <= idx && idx < list.size()) {
  // idx is considered @IndexFor("list") here
  list.remove(0);       // shrink the list
  String s = list.get(idx);  // <-- must recheck, idx may now be out of range
}
\end{Verbatim}

After the call to \code{list.remove(0)}, the checker invalidates the fact that \code{idx}
was a valid index, because the removal may have decreased the list’s length (or shifted indices).
It will warn that the subsequent \code{list.get(idx)} is unsafe unless the code re-establishes
the index bound (for instance, by checking \code{idx < list.size()} again after the removal).

\textbf{The @SideEffectsOnly annotation:} To help identify methods that have important side effects
(and no relevant return value), the Index Checker provides a method annotation \code{@SideEffectsOnly}.
This annotation indicates that the method’s primary purpose is to produce side effects, and thus any
index facts involving objects that the method could modify should be invalidated afterward. In
contrast to @ChangesLength (which is specific to length changes of a particular collection),
@SideEffectsOnly is a broader signal: when a method is marked @SideEffectsOnly, the checker will
conservatively assume that it may have changed the state of any object it had access to (particularly
via its parameters or the receiver). For index checking, this means the method call acts as a “hard stop”
for flow-sensitive information: after the call, indices that were previously considered safe may need to
be re-validated. For example, if you call a method \code{updateList(List\<?> lst) @SideEffectsOnly} on
a list, the checker will not carry any index assumptions about \code{lst} across that call (because
\code{updateList} might have added or removed elements). In effect, marking a method @SideEffectsOnly
forces the same kind of index fact invalidation as an explicit mutation. Library developers can use this
annotation on void methods or others that solely mutate structures to ensure soundness. Combined with the
Purity Checker (which marks side-effect-free methods), this mechanism helps the Index Checker distinguish
pure computations from mutating ones. A method that is known to be @Pure (no side effects) will \emph{not}
invalidate index facts for its arguments, whereas a @SideEffectsOnly method will.

\textbf{Summary of flow rules:} In summary, whenever your code performs an operation that might affect a collection’s length:
\begin{itemize}
\item
  If the operation is through a @Shrinkable (or unannotated, defaulting to @UnShrinkableRef) reference,
  the checker will drop any knowledge about indices for that collection. You must add new checks
  after the mutation if you want to use indices safely.
\item
  If the operation is through a @GrowOnly reference, the checker does not need to drop index facts for that collection,
  because the length can only increase (making previously safe indices still safe).
\item
  If a method call is made and that method is neither known to be pure nor annotated otherwise, the checker errs on the
  side of caution and may invalidate index info for any involved collections. By using @ChangesLength and @SideEffectsOnly
  annotations in the library, this behavior is made more precise, targeting the specific collections that are affected.
\item
  Code that relies on previously checked indices across mutating calls will trigger warnings, prompting the developer
  to either adjust the code structure or add appropriate re-checks or annotations (such as splitting a single method
  into two phases, or copying the collection size to a local variable before mutation, etc.).
\end{itemize}

\subsectionAndLabel{Using the new annotations in practice}{index-mutable-usage}

The implementation of these features involves adding annotations to both library code (the JDK or third-party collection classes)
and your application code:
\begin{itemize}
\item
  \textbf{Library annotation (JDK):}
    The Java collections library is annotated so that the Index Checker knows how its methods affect lengths. For example,
    \code{List.remove} is annotated to indicate it requires a @Shrinkable receiver (meaning you should have the reference as
    @Shrinkable to call it without error), and it is marked @ChangesLength on the receiver. Methods like \code{add} might be marked
    @ChangesLength as well (to indicate growth), and \code{subList} returns a list annotated with @BackedBy("this"). These annotations
    are trusted by the checker. (The framework does not re-verify the JDK itself; it assumes the library methods behave as annotated.)
    As a result, when you use standard collections, you’ll get appropriate warnings or lack thereof based on these annotations. For
    instance, calling \code{myList.remove(i)} where \code{myList} is not annotated as @Shrinkable will produce an error, because the
    library method signature effectively expects a Shrinkable receiver.

\item
  \textbf{Application code:}
  As an application developer, you primarily use these qualifiers to document and verify your intended mutation patterns. 
  Here are some guidelines:
  \begin{itemize}
    \item 
      If you never remove elements from a particular collection (you only add or read), you don’t need to write any 
      annotation – it will default to @UnShrinkableRef and the checker will assume no removals. If you want to be explicit 
      (for documentation), you can annotate it as @UnShrinkableRef or @GrowOnly. Use @GrowOnly if you want to make the stronger 
      claim that not only will you not remove, but also that the collection isn’t shrunk via any alias. This could be the 
      case for a list that is built up over time but never pruned.
    \item 
      If you do remove elements from a collection, annotate the reference (or variable) as \refqualclass{checker/index/qual}{Shrinkable}. 
      For example:
        \begin{Verbatim}
          import org.checkerframework.checker.index.qual.Shrinkable;
          @Shrinkable List<String> lines = new ArrayList<>();
          ...
          lines.add("first");
          lines.remove(0);
        \end{Verbatim}
      Marking \code{lines} as @Shrinkable tells the checker that removals are intentional. 
      The checker will allow \code{lines.remove(0)} to be called. It will, however, invalidate index facts for 
      \code{lines} afterward as discussed. If you omit the @Shrinkable annotation in this scenario, the checker 
      would produce an error at the call to \code{remove}, because by default it assumes such calls are not allowed.
    \item 
      If you have a reference that you know may be subject to complex mutations that the checker cannot easily reason 
      about (perhaps the collection is modified in deeply aliasing structures or via reflection, etc.), you can use 
      \refqualclass{checker/index/qual}{UncheckedShrinkable} as a last resort. For example, 
      \code{@UncheckedShrinkable List<Foo> legacyList;}. This will suppress index-out-of-bounds errors for operations 
      on \code{legacyList}, under the assumption that you will manage its safety manually or via tests. Use this 
      sparingly – it’s better to design your code such that @Shrinkable and @UnShrinkableRef/@GrowOnly references are sufficient.
    \item 
      When writing new APIs or methods in your code, consider whether they mutate collections. If a method’s sole 
      purpose is to mutate a collection, you might mark it as @SideEffectsOnly and/or @ChangesLength on the 
      relevant parameters. For example:
        \begin{Verbatim}
          @SideEffectsOnly
          void trimList(@Shrinkable List\<?> list) { ... remove elements from list ... }
        \end{Verbatim}
      Annotating \code{list} as @Shrinkable makes it clear the method might shrink it, and @SideEffectsOnly 
      on the method means callers should not expect any index relationships to remain valid after calling 
      \code{trimList}. The Index Checker will enforce these expectations at call sites.
    \item 
      The @BackedBy annotation would mostly appear in library or framework code. In your own code, you might use 
      it if you implement a view onto a collection. For instance, if you wrote a custom class \code{FilteredList} 
      that presents a filtered view of an underlying list, you could annotate \code{FilteredList} with @BackedBy 
      to link it to the original. This will help the checker understand that a mutation to the filtered view 
      affects the base list.
  \end{itemize}
\item
  \textbf{Example:}
    Suppose you maintain two lists that should always have the same length (parallel arrays pattern).
    You can use the Index Checker’s existing same-length mechanism (the @SameLen annotation)
    \emph{together} with the new qualifiers. You might declare:

    \begin{Verbatim}
      List<String> @SameLen("ids") @Shrinkable names;
      List<Integer> @Shrinkable ids;
    \end{Verbatim}
  and ensure that you perform removals on both lists in tandem. The @SameLen("ids") on \code{names}
  tells the Index Checker that \code{names} and \code{ids} start with the same length, but because
  they are Shrinkable, you must also ensure any removal keeps them in sync. The checker will
  invalidate index info on both if one is mutated, so you would re-establish the relationship
  after any modifications (perhaps by asserting their sizes match within the code). In future, the
  checker might provide a more automated way to handle such “linked-list” mutations (see below).

\item
  \textbf{Implementation notes:}
    Under the hood, the Index Checker enforces these annotations by extending the type rules.
    For instance, the method invocation rule checks the receiver’s qualifier against what the
    method requires: calling a method that is known to shrink the list will produce an error if
    the receiver is not @Shrinkable (or @UncheckedShrinkable). Additionally, the dataflow
    (flow-sensitive analysis) component of the checker is augmented to drop information when it
    encounters a method call or mutation on a potentially-shrinking reference. These changes are
    largely transparent to users – you experience them as error messages or lack thereof.
\end{itemize}
Overall, using the new system typically involves adding a few well-placed annotations. The
most common use case will be marking a variable as @Shrinkable in sections of code that
remove elements from a collection. In exchange, you gain confidence (via compiler errors or
lack of them) that you have correctly handled index-safety even as your collections change size.

\subsectionAndLabel{Advanced features and future improvements}{index-mutable-future}

The current design is a significant step toward handling mutable-length collections, but there
are several advanced enhancements and alternate designs that may be explored in the future:
\begin{itemize}
\item
  \textbf{Leveraging uniqueness for safe mutation:}
  If a reference is known to be \emph{unique} (no other aliases to the same object exist),
  then shrinking the collection through that reference can be made much safer. In such a scenario,
  once you perform a removal, you as the programmer know exactly how the length changed and can
  immediately adjust or re-check indices. A potential feature is automatic conversion of unique
  references between mutation modes. For example, the checker (in conjunction with an Aliasing Checker)
  could determine that a newly created list is unique, allow you to use it with full mutation
  (treat it as @Shrinkable during a building phase), and then once it’s published to other code,
  convert or restrict it to @UnShrinkableRef. This would let you mutate freely when it’s safe
  (no aliases yet) and still have sound checking when aliases might appear.

\item
  \textbf{Alternate qualifier hierarchies:}
    We have chosen one particular subtyping hierarchy for GrowOnly and Shrinkable references,
    but other hierarchies were considered. For instance, one could imagine @Shrinkable and
    @GrowOnly as two parallel dimensions (incomparable types) with a common supertype, or even
    having @GrowOnly as a supertype of @Shrinkable (or vice versa). Each design has trade-offs
    in terms of flexibility and complexity. In our design, @UnShrinkableRef is the top and we
    introduced @UncheckedShrinkable as a subtype of @Shrinkable. Another possible design could
    have been a single mutable qualifier with a flag for allowing removes. Through testing, the
    chosen hierarchy proved to enforce the constraints without unduly burdening the developer.
    This hierarchy ensures, for example, that no @GrowOnly can be mistakenly used in place of a
    @Shrinkable (preventing silent unsoundness). The section in the developer manual discusses some
    of these alternate designs and why they were not adopted.

\item
  \textbf{Same-length collection invariants:}
    The Index Checker already supports a @SameLen annotation for fixed-size sequences, indicating
    that two sequences have equal length. Extending this concept to mutable sequences is an area of
    interest. For example, you might have two lists that are always mutated together, so that they
    remain the same length at all times. A future enhancement could introduce a mechanism to declare
    that relationship more directly for Shrinkable lists. This might involve an effect annotation
    that a method changes two collections in tandem, or a stronger guarantee that a mutation on one
    triggers an automatic mutation on the other. While currently the checker can verify equal lengths at
    particular program points (you can always re-check sizes after mutations), a dedicated feature could
    maintain an invariant of equal lengths throughout the scope. This would likely require more
    sophisticated analysis (to ensure every mutation to one is matched by a mutation to the other),
    or possibly integrating with a relational invariant checker.

\item
  \textbf{Unified effect and purity annotations:}
    The introduction of @ChangesLength and @SideEffectsOnly raises the question of whether these can
    be unified with existing effect systems (such as the Purity Checker’s @Pure and the generalized
    effect system for determinism or thread-safety). In the future, we might generalize @ChangesLength
    into a broader category of “effects on data structures” or integrate it with a more universal effect
    tracking mechanism. For example, one could imagine an annotation that indicates a method
    \emph{may modify its receiver’s state in ways that include length changes} and a type system that
    reasons about such effects across the program. A unified effect system could reduce duplication of
    annotations and provide a single framework to reason about side effects (with the Index Checker being
    one consumer of that information). This is a complex undertaking, as it would require balancing precision
    with usability, but it could make the framework more powerful and general.

\item
  \textbf{Simpler heuristic checks for side effects:}
    In absence of full pointer analysis, the current approach is deliberately conservative. Future work
    could introduce simpler, targeted analyses to catch common patterns of misuse without a full alias
    analysis. For instance, a possible check could be: if a previously-validated index is used after a
    method call that takes a collection as a parameter (and that method is not known to be pure), warn
    the developer that the index might no longer be valid. This wouldn’t be sound in all cases, but it
    could heuristically catch likely bugs even when the annotations are missing or incomplete. Another
    idea is to integrate with the Must Call/Must Release framework (or other typestate-like checkers) to
    ensure that any sequence that is shrunk has certain post-conditions (like re-checking its size or updating
    related indices). These “simple effect checks” would not guarantee full safety, but they can provide
    guidance in code that hasn’t yet been fully annotated for index mutability.
\end{itemize}

%%  LocalWords:  NegativeArraySizeException pre myArray IndexFor someArray
%%  LocalWords:  MyJavaFile LTLengthOf LTEqLengthOf GTENegativeOne GTE str
%%  LocalWords:  LowerBoundUnknown LTOMLengthOf LTEq LTOM UpperBoundBottom
%%  LocalWords:  UpperBoundUnknown MinLen MinLenBottom SameLen indexOf abc
%%  LocalWords:  SameLenUnknown SameLenBottom lastIndexOf html lang charAt
%%  LocalWords:  LengthOf IndexOrLow PolyIndex PolyLowerBound PolyLength
%%  LocalWords:  PolyUpperBound PolySameLen PolyValue LowerBoundBottom
%%  LocalWords:  lowerbound upperbound EnsuresLTLengthOf targetValue
%%  LocalWords:  EnsuresLTLengthOfIf boolean HasSubsequence LessThan
%%  LocalWords:  minlen ArrayLenRange ArrayLen EnsuresMinLenIf samelen
%%  LocalWords:  searchindex binarySearch SearchIndexFor NegativeIndexFor
%%  LocalWords:  SearchIndex bitwise SearchIndexBottom SearchIndexUnknown
%%  LocalWords:  Substring substringindex substring SubstringIndexFor
%%  LocalWords:  SubstringIndexBottom SubstringIndexUnknown LessThanBottom
%%  LocalWords:  LessThanUnknown typecheck typechecks system''
% LocalWords:  UpperBoundLiteral
